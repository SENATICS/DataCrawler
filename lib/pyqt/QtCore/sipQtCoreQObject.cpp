/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.16.2 on Wed Sep  3 09:36:12 2014
 *
 * Copyright (c) 2014 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt.
 * 
 * This file may be used under the terms of the GNU General Public
 * License versions 2.0 or 3.0 as published by the Free Software
 * Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
 * included in the packaging of this file.  Alternatively you may (at
 * your option) use any later version of the GNU General Public
 * License if such license has been publicly approved by Riverbank
 * Computing Limited (or its successors, if any) and the KDE Free Qt
 * Foundation. In addition, as a special exception, Riverbank gives you
 * certain additional rights. These rights are described in the Riverbank
 * GPL Exception version 1.1, which can be found in the file
 * GPL_EXCEPTION.txt in this package.
 * 
 * If you are unsure which license is appropriate for your use, please
 * contact the sales department at sales@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtCore.h"

#line 34 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
#include <qobject.h>
#line 34 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

#line 31 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 38 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 31 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 41 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 355 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 44 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 338 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 47 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 274 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 50 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 33 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qlist.sip"
#include <qlist.h>
#line 53 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 37 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 56 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 35 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 59 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 120 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qlist.sip"
#include <qlist.h>
#line 62 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 31 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qthread.sip"
#include <qthread.h>
#line 65 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 36 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qstring.sip"
#include <qstring.h>
#line 68 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 35 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 71 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
#line 38 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
// This is needed by the tr() and trUt8() handwritten implementations.
#include <qcoreapplication.h>


// These are the helper functions for QObject::findChild() and
// QObject::findChildren.

// Wrap the given type in a 1-tuple.
static PyObject *qtcore_type_to_tuple(PyObject *type)
{
    PyObject *tuple = PyTuple_New(1);

    if (tuple)
    {
        Py_INCREF(type);
        PyTuple_SET_ITEM(tuple, 0, type);
    }

    return tuple;
}


// Check all elements of a given tuple are type objects and return a new
// reference to the tuple if so.
static PyObject *qtcore_check_tuple_types(PyObject *types)
{
    for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(types); ++i)
        if (!PyObject_TypeCheck(PyTuple_GET_ITEM(types, i), &PyType_Type))
        {
            PyErr_SetString(PyExc_TypeError,
                    "all elements of the types argument must be type objects");
            return 0;
        }

    Py_INCREF(types);
    return types;
}


// Do the main work of finding a child.
static PyObject *qtcore_do_find_child(const QObject *parent, PyObject *types, const QString &name)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return 0;

        if (name.isNull() || obj->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    return pyo;

        Py_DECREF(pyo);
    }

    for (i = 0; i < children.size(); ++i)
    {
        PyObject *pyo = qtcore_do_find_child(children.at(i), types, name);

        if (pyo != Py_None)
            return pyo;

        Py_DECREF(pyo);
    }

    Py_INCREF(Py_None);
    return Py_None;
}


// Find a child that is one of a number of types and with an optional name.
static PyObject *qtcore_FindChild(const QObject *parent, PyObject *types, const QString &name)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *child = qtcore_do_find_child(parent, types, name);

    Py_DECREF(types);

    return child;
}


// Do the main work of finding the children with a string name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QString &name, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (name.isNull() || obj->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        bool ok = qtcore_do_find_children(obj, types, name, list);

        if (!ok)
            return false;
    }

    return true;
}


// Find a child that is one of a number of types and with an optional string
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QString &name)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, name, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a regular expression name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegExp &re, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (re.indexIn(obj->objectName()) >= 0)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        bool ok = qtcore_do_find_children(obj, types, re, list);

        if (!ok)
            return false;
    }

    return true;
}


// Find a child that is one of a number of types and with an optional regular
// expression name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegExp &re)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}
#line 272 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"


class sipQObject : public QObject
{
public:
    sipQObject(QObject*);
    virtual ~sipQObject();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const char*);
    void connectNotify(const char*);
    void customEvent(QEvent*);
    void childEvent(QChildEvent*);
    void timerEvent(QTimerEvent*);
    bool eventFilter(QObject*,QEvent*);
    bool event(QEvent*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQObject(const sipQObject &);
    sipQObject &operator = (const sipQObject &);

    char sipPyMethods[7];
};

sipQObject::sipQObject(QObject*a0): QObject(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQObject::~sipQObject()
{
    sipCommonDtor(sipPySelf);
}

const QMetaObject *sipQObject::metaObject() const
{
    return sip_QtCore_qt_metaobject(sipPySelf,sipType_QObject);
}

int sipQObject::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id = QObject::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtCore_qt_metacall(sipPySelf,sipType_QObject,_c,_id,_a);

    return _id;
}

void *sipQObject::qt_metacast(const char *_clname)
{
    return (sip_QtCore_qt_metacast(sipPySelf, sipType_QObject, _clname)) ? this : QObject::qt_metacast(_clname);
}

void sipQObject::disconnectNotify(const char*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
        QObject::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*);

    sipVH_QtCore_24(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::connectNotify(const char*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
        QObject::connectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const char*);

    sipVH_QtCore_24(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::customEvent(QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
        QObject::customEvent(a0);
        return;
    }

    extern void sipVH_QtCore_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QEvent*);

    sipVH_QtCore_17(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::childEvent(QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
        QObject::childEvent(a0);
        return;
    }

    extern void sipVH_QtCore_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QChildEvent*);

    sipVH_QtCore_25(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipQObject::timerEvent(QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
        QObject::timerEvent(a0);
        return;
    }

    extern void sipVH_QtCore_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QTimerEvent*);

    sipVH_QtCore_9(sipGILState, 0, sipPySelf, sipMeth, a0);
}

bool sipQObject::eventFilter(QObject*a0,QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return QObject::eventFilter(a0,a1);

    extern bool sipVH_QtCore_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QObject*,QEvent*);

    return sipVH_QtCore_18(sipGILState, 0, sipPySelf, sipMeth, a0, a1);
}

bool sipQObject::event(QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return QObject::event(a0);

    extern bool sipVH_QtCore_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QEvent*);

    return sipVH_QtCore_5(sipGILState, 0, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QObject_metaObject, "QObject.metaObject() -> QMetaObject");

extern "C" {static PyObject *meth_QObject_metaObject(PyObject *, PyObject *);}
static PyObject *meth_QObject_metaObject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            const QMetaObject*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->metaObject();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(const_cast<QMetaObject *>(sipRes),sipType_QMetaObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_metaObject, doc_QObject_metaObject);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_pyqtConfigure, "QObject.pyqtConfigure(...)\n"
    "\n"
    "Each keyword argument is either the name of a Qt property or a Qt signal.\n"
    "For properties the property is set to the given value which should be of an\n"
    "appropriate type.\n"
    "For signals the signal is connected to the given value which should be a\n"
    "callable.");

extern "C" {static PyObject *meth_QObject_pyqtConfigure(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_pyqtConfigure(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
#line 381 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        return qpycore_pyqtconfigure(sipSelf, sipArgs, sipKwds);
#line 501 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
}


PyDoc_STRVAR(doc_QObject___getattr__, "QObject.__getattr__(str) -> object");

extern "C" {static PyObject *meth_QObject___getattr__(PyObject *, PyObject *);}
static PyObject *meth_QObject___getattr__(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            PyObject * sipRes = 0;

#line 386 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_getattr(const_cast<QObject *>(sipCpp), sipSelf, a0);
#line 522 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName___getattr__, doc_QObject___getattr__);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_event, "QObject.event(QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_event(PyObject *, PyObject *);}
static PyObject *meth_QObject_event(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QEvent* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp->QObject::event(a0) : sipCpp->event(a0));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_event, doc_QObject_event);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_eventFilter, "QObject.eventFilter(QObject, QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_eventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_eventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QObject* a0;
        QEvent* a1;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, sipType_QEvent, &a1))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp->QObject::eventFilter(a0,a1) : sipCpp->eventFilter(a0,a1));
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_eventFilter, doc_QObject_eventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_tr, "QObject.tr(str, str disambiguation=None, int n=-1) -> QString");

extern "C" {static PyObject *meth_QObject_tr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_tr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const char* a1 = 0;
        int a2 = -1;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_disambiguation,
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BP0|si", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1, &a2))
        {
            QString*sipRes = 0;
            int sipIsErr = 0;

#line 404 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::CodecForTr);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::CodecForTr, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
#line 638 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_tr, doc_QObject_tr);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_trUtf8, "QObject.trUtf8(str, str disambiguation=None, int n=-1) -> QString");

extern "C" {static PyObject *meth_QObject_trUtf8(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_trUtf8(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const char* a1 = 0;
        int a2 = -1;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_disambiguation,
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BP0|si", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1, &a2))
        {
            QString*sipRes = 0;
            int sipIsErr = 0;

#line 463 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::UnicodeUTF8, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
#line 694 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_trUtf8, doc_QObject_trUtf8);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChild, "QObject.findChild(type, QString name=QString()) -> QObject\n"
    "QObject.findChild(tuple, QString name=QString()) -> QObject");

extern "C" {static PyObject *meth_QObject_findChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 521 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 740 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 529 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 772 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChild, doc_QObject_findChild);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChildren, "QObject.findChildren(type, QString name=QString()) -> list-of-QObject\n"
    "QObject.findChildren(tuple, QString name=QString()) -> list-of-QObject\n"
    "QObject.findChildren(type, QRegExp) -> list-of-QObject\n"
    "QObject.findChildren(tuple, QRegExp) -> list-of-QObject");

extern "C" {static PyObject *meth_QObject_findChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 537 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 821 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 545 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 853 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QRegExp* a1;
        const QObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BTJ9", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QRegExp, &a1))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 553 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 878 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QRegExp* a1;
        const QObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BTJ9", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QRegExp, &a1))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 561 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1);
        
        if (!sipRes)
            sipIsErr = 1;
#line 902 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChildren, doc_QObject_findChildren);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_emit, "QObject.emit(SIGNAL(), ...)");

extern "C" {static PyObject *meth_QObject_emit(PyObject *, PyObject *);}
static PyObject *meth_QObject_emit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        char* a0;
        PyObject * a1;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BGW", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1))
        {
            int sipIsErr = 0;

#line 569 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        if (!qpycore_qobject_emit(sipCpp, a0, a1))
            sipIsErr = 1;
#line 937 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            Py_DECREF(a1);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_emit, doc_QObject_emit);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_objectName, "QObject.objectName() -> QString");

extern "C" {static PyObject *meth_QObject_objectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_objectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new QString(sipCpp->objectName());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_objectName, doc_QObject_objectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setObjectName, "QObject.setObjectName(QString)");

extern "C" {static PyObject *meth_QObject_setObjectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_setObjectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QString* a0;
        int a0State = 0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QObject, &sipCpp, sipType_QString,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setObjectName(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setObjectName, doc_QObject_setObjectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isWidgetType, "QObject.isWidgetType() -> bool");

extern "C" {static PyObject *meth_QObject_isWidgetType(PyObject *, PyObject *);}
static PyObject *meth_QObject_isWidgetType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->isWidgetType();
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isWidgetType, doc_QObject_isWidgetType);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_signalsBlocked, "QObject.signalsBlocked() -> bool");

extern "C" {static PyObject *meth_QObject_signalsBlocked(PyObject *, PyObject *);}
static PyObject *meth_QObject_signalsBlocked(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->signalsBlocked();
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_signalsBlocked, doc_QObject_signalsBlocked);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_blockSignals, "QObject.blockSignals(bool) -> bool");

extern "C" {static PyObject *meth_QObject_blockSignals(PyObject *, PyObject *);}
static PyObject *meth_QObject_blockSignals(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->blockSignals(a0);
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_blockSignals, doc_QObject_blockSignals);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_thread, "QObject.thread() -> QThread");

extern "C" {static PyObject *meth_QObject_thread(PyObject *, PyObject *);}
static PyObject *meth_QObject_thread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QThread*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->thread();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QThread,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_thread, doc_QObject_thread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_moveToThread, "QObject.moveToThread(QThread)");

extern "C" {static PyObject *meth_QObject_moveToThread(PyObject *, PyObject *);}
static PyObject *meth_QObject_moveToThread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QThread* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QThread, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->moveToThread(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_moveToThread, doc_QObject_moveToThread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_startTimer, "QObject.startTimer(int) -> int");

extern "C" {static PyObject *meth_QObject_startTimer(PyObject *, PyObject *);}
static PyObject *meth_QObject_startTimer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->startTimer(a0);
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_startTimer, doc_QObject_startTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_killTimer, "QObject.killTimer(int)");

extern "C" {static PyObject *meth_QObject_killTimer(PyObject *, PyObject *);}
static PyObject *meth_QObject_killTimer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->killTimer(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_killTimer, doc_QObject_killTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_children, "QObject.children() -> list-of-QObject");

extern "C" {static PyObject *meth_QObject_children(PyObject *, PyObject *);}
static PyObject *meth_QObject_children(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QObjectList*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new QObjectList(sipCpp->children());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0101QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_children, doc_QObject_children);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setParent, "QObject.setParent(QObject)");

extern "C" {static PyObject *meth_QObject_setParent(PyObject *, PyObject *);}
static PyObject *meth_QObject_setParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject* a0;
        sipWrapper *sipOwner = 0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJH", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, &sipOwner))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setParent(a0);
            Py_END_ALLOW_THREADS

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setParent, doc_QObject_setParent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_installEventFilter, "QObject.installEventFilter(QObject)");

extern "C" {static PyObject *meth_QObject_installEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_installEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->installEventFilter(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_installEventFilter, doc_QObject_installEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_removeEventFilter, "QObject.removeEventFilter(QObject)");

extern "C" {static PyObject *meth_QObject_removeEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_removeEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->removeEventFilter(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_removeEventFilter, doc_QObject_removeEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_connect, "QObject.connect(QObject, SIGNAL(), QObject, SLOT(), Qt.ConnectionType=Qt.AutoConnection) -> bool\n"
    "QObject.connect(QObject, SIGNAL(), callable, Qt.ConnectionType=Qt.AutoConnection) -> bool\n"
    "QObject.connect(QObject, SIGNAL(), SLOT(), Qt.ConnectionType=Qt.AutoConnection) -> bool");

extern "C" {static PyObject *meth_QObject_connect(PyObject *, PyObject *);}
static PyObject *meth_QObject_connect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        char* a1;
        PyObject * a2;
        char* a3;
        Qt::ConnectionType a4 = Qt::AutoConnection;

        if (sipParseArgs(&sipParseErr, sipArgs, "RGRS|E", &a0, &a1, &a2, &a3, sipType_Qt_ConnectionType, &a4))
        {
            PyObject * sipRes = 0;

#line 596 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = sipConnectRx(a0, a1, a2, a3, (int)a4);
#line 1365 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    {
        PyObject * a0;
        char* a1;
        PyObject * a2;
        Qt::ConnectionType a3 = Qt::AutoConnection;

        if (sipParseArgs(&sipParseErr, sipArgs, "RGF|E", &a0, &a1, &a2, sipType_Qt_ConnectionType, &a3))
        {
            PyObject * sipRes = 0;

#line 601 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = sipConnectRx(a0, a1, a2, 0, (int)a3);
#line 1383 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    {
        PyObject * a0;
        char* a1;
        char* a2;
        Qt::ConnectionType a3 = Qt::AutoConnection;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BRGS|E", &sipSelf, sipType_QObject, &sipCpp, &a0, &a1, &a2, sipType_Qt_ConnectionType, &a3))
        {
            PyObject * sipRes = 0;

#line 606 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = sipConnectRx(a0, a1, sipSelf, a2, (int)a3);
#line 1402 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_connect, doc_QObject_connect);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnect, "QObject.disconnect(QObject, SIGNAL(), QObject, SLOT()) -> bool\n"
    "QObject.disconnect(QObject, SIGNAL(), callable) -> bool");

extern "C" {static PyObject *meth_QObject_disconnect(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnect(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        char* a1;
        PyObject * a2;
        char* a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "RGRS", &a0, &a1, &a2, &a3))
        {
            PyObject * sipRes = 0;

#line 611 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = sipDisconnectRx(a0, a1, a2, a3);
#line 1435 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    {
        PyObject * a0;
        char* a1;
        PyObject * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "RGF", &a0, &a1, &a2))
        {
            PyObject * sipRes = 0;

#line 616 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipRes = sipDisconnectRx(a0, a1, a2, 0);
#line 1452 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnect, doc_QObject_disconnect);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectInfo, "QObject.dumpObjectInfo()");

extern "C" {static PyObject *meth_QObject_dumpObjectInfo(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->dumpObjectInfo();
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectInfo, doc_QObject_dumpObjectInfo);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectTree, "QObject.dumpObjectTree()");

extern "C" {static PyObject *meth_QObject_dumpObjectTree(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectTree(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->dumpObjectTree();
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectTree, doc_QObject_dumpObjectTree);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dynamicPropertyNames, "QObject.dynamicPropertyNames() -> list-of-QByteArray");

extern "C" {static PyObject *meth_QObject_dynamicPropertyNames(PyObject *, PyObject *);}
static PyObject *meth_QObject_dynamicPropertyNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QList<QByteArray>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new QList<QByteArray>(sipCpp->dynamicPropertyNames());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dynamicPropertyNames, doc_QObject_dynamicPropertyNames);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setProperty, "QObject.setProperty(str, QVariant) -> bool");

extern "C" {static PyObject *meth_QObject_setProperty(PyObject *, PyObject *);}
static PyObject *meth_QObject_setProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QVariant* a1;
        int a1State = 0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BsJ1", &sipSelf, sipType_QObject, &sipCpp, &a0, sipType_QVariant,&a1, &a1State))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->setProperty(a0,*a1);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QVariant *>(a1),sipType_QVariant,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setProperty, doc_QObject_setProperty);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_property, "QObject.property(str) -> QVariant");

extern "C" {static PyObject *meth_QObject_property(PyObject *, PyObject *);}
static PyObject *meth_QObject_property(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            QVariant*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new QVariant(sipCpp->property(a0));
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_property, doc_QObject_property);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_parent, "QObject.parent() -> QObject");

extern "C" {static PyObject *meth_QObject_parent(PyObject *, PyObject *);}
static PyObject *meth_QObject_parent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QObject*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->parent();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_parent, doc_QObject_parent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_inherits, "QObject.inherits(str) -> bool");

extern "C" {static PyObject *meth_QObject_inherits(PyObject *, PyObject *);}
static PyObject *meth_QObject_inherits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->inherits(a0);
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_inherits, doc_QObject_inherits);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_deleteLater, "QObject.deleteLater()");

extern "C" {static PyObject *meth_QObject_deleteLater(PyObject *, PyObject *);}
static PyObject *meth_QObject_deleteLater(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->deleteLater();
            Py_END_ALLOW_THREADS

            sipTransferTo(sipSelf, NULL);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_deleteLater, doc_QObject_deleteLater);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_sender, "QObject.sender() -> QObject");

extern "C" {static PyObject *meth_QObject_sender(PyObject *, PyObject *);}
static PyObject *meth_QObject_sender(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "p", &sipSelf, sipType_QObject, &sipCpp))
        {
            QObject*sipRes = 0;

#line 643 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        typedef QObject *(*helper_func)(QObject *);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qpycore_qobject_sender");
        
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (helper)
            sipRes = helper(sipRes);
#line 1739 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_sender, doc_QObject_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_receivers, "QObject.receivers(SIGNAL()) -> int");

extern "C" {static PyObject *meth_QObject_receivers(PyObject *, PyObject *);}
static PyObject *meth_QObject_receivers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pG", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            int sipRes = 0;

#line 669 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        // We need to take into account any proxies for Python signals. Import the
        // helper if it hasn't already been done.
        typedef int (*helper_func)(QObject *, const char *, int);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qpycore_qobject_receivers");
        
        // PyQt5: Get rid of the const casts.
        if (helper)
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            sipRes = helper(const_cast<QObject *>(sipCpp), a0, sipCpp->receivers(a0));
        #else
            sipRes = helper(const_cast<QObject *>(static_cast<const QObject *>(sipCpp)), a0, sipCpp->sipProtect_receivers(a0));
        #endif
#line 1784 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_receivers, doc_QObject_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_timerEvent, "QObject.timerEvent(QTimerEvent)");

extern "C" {static PyObject *meth_QObject_timerEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_timerEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QTimerEvent* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QTimerEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp->QObject::timerEvent(a0) : sipCpp->timerEvent(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_timerEvent, doc_QObject_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_childEvent, "QObject.childEvent(QChildEvent)");

extern "C" {static PyObject *meth_QObject_childEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_childEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QChildEvent* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QChildEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp->QObject::childEvent(a0) : sipCpp->childEvent(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_childEvent, doc_QObject_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_customEvent, "QObject.customEvent(QEvent)");

extern "C" {static PyObject *meth_QObject_customEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_customEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QEvent* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp->QObject::customEvent(a0) : sipCpp->customEvent(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_customEvent, doc_QObject_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_connectNotify, "QObject.connectNotify(SIGNAL())");

extern "C" {static PyObject *meth_QObject_connectNotify(PyObject *, PyObject *);}
static PyObject *meth_QObject_connectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        char* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pG", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp->QObject::connectNotify(a0) : sipCpp->connectNotify(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_connectNotify, doc_QObject_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnectNotify, "QObject.disconnectNotify(SIGNAL())");

extern "C" {static PyObject *meth_QObject_disconnectNotify(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        char* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pG", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp->QObject::disconnectNotify(a0) : sipCpp->disconnectNotify(a0));
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnectNotify, doc_QObject_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_senderSignalIndex, "QObject.senderSignalIndex() -> int");

extern "C" {static PyObject *meth_QObject_senderSignalIndex(PyObject *, PyObject *);}
static PyObject *meth_QObject_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "p", &sipSelf, sipType_QObject, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->senderSignalIndex();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_senderSignalIndex, doc_QObject_senderSignalIndex);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_QObject(void *, const sipTypeDef *);}
static void *cast_QObject(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_QObject)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QObject(void *, int);}
static void release_QObject(void *sipCppV,int)
{
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);

    Py_BEGIN_ALLOW_THREADS

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();

    Py_END_ALLOW_THREADS
}


extern "C" {static int final_QObject(PyObject *, void *, PyObject *, PyObject **);}
static int final_QObject(PyObject *sipSelf, void *sipCppV, PyObject *sipKwds, PyObject **sipUnused)
{
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);

#line 240 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
    return qpycore_qobject_finalisation(sipSelf, sipCpp, sipKwds, sipUnused);
#line 2011 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"
}


extern "C" {static void dealloc_QObject(sipSimpleWrapper *);}
static void dealloc_QObject(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipQObject *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_QObject(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_QObject(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QObject(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQObject *sipCpp = 0;

    {
        QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipQObject(a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QObject[] = {
    {SIP_MLNAME_CAST(sipName___getattr__), meth_QObject___getattr__, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject___getattr__)},
    {SIP_MLNAME_CAST(sipName_blockSignals), meth_QObject_blockSignals, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_blockSignals)},
    {SIP_MLNAME_CAST(sipName_childEvent), meth_QObject_childEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_childEvent)},
    {SIP_MLNAME_CAST(sipName_children), meth_QObject_children, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_children)},
    {SIP_MLNAME_CAST(sipName_connect), meth_QObject_connect, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_connect)},
    {SIP_MLNAME_CAST(sipName_connectNotify), meth_QObject_connectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_connectNotify)},
    {SIP_MLNAME_CAST(sipName_customEvent), meth_QObject_customEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_customEvent)},
    {SIP_MLNAME_CAST(sipName_deleteLater), meth_QObject_deleteLater, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_deleteLater)},
    {SIP_MLNAME_CAST(sipName_disconnect), meth_QObject_disconnect, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnect)},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), meth_QObject_disconnectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnectNotify)},
    {SIP_MLNAME_CAST(sipName_dumpObjectInfo), meth_QObject_dumpObjectInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectInfo)},
    {SIP_MLNAME_CAST(sipName_dumpObjectTree), meth_QObject_dumpObjectTree, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectTree)},
    {SIP_MLNAME_CAST(sipName_dynamicPropertyNames), meth_QObject_dynamicPropertyNames, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dynamicPropertyNames)},
    {SIP_MLNAME_CAST(sipName_emit), meth_QObject_emit, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_emit)},
    {SIP_MLNAME_CAST(sipName_event), meth_QObject_event, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_event)},
    {SIP_MLNAME_CAST(sipName_eventFilter), meth_QObject_eventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_eventFilter)},
    {SIP_MLNAME_CAST(sipName_findChild), (PyCFunction)meth_QObject_findChild, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChild)},
    {SIP_MLNAME_CAST(sipName_findChildren), (PyCFunction)meth_QObject_findChildren, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChildren)},
    {SIP_MLNAME_CAST(sipName_inherits), meth_QObject_inherits, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_inherits)},
    {SIP_MLNAME_CAST(sipName_installEventFilter), meth_QObject_installEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_installEventFilter)},
    {SIP_MLNAME_CAST(sipName_isWidgetType), meth_QObject_isWidgetType, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isWidgetType)},
    {SIP_MLNAME_CAST(sipName_killTimer), meth_QObject_killTimer, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_killTimer)},
    {SIP_MLNAME_CAST(sipName_metaObject), meth_QObject_metaObject, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_metaObject)},
    {SIP_MLNAME_CAST(sipName_moveToThread), meth_QObject_moveToThread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_moveToThread)},
    {SIP_MLNAME_CAST(sipName_objectName), meth_QObject_objectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_objectName)},
    {SIP_MLNAME_CAST(sipName_parent), meth_QObject_parent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_parent)},
    {SIP_MLNAME_CAST(sipName_property), meth_QObject_property, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_property)},
    {SIP_MLNAME_CAST(sipName_pyqtConfigure), (PyCFunction)meth_QObject_pyqtConfigure, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_pyqtConfigure)},
    {SIP_MLNAME_CAST(sipName_receivers), meth_QObject_receivers, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_receivers)},
    {SIP_MLNAME_CAST(sipName_removeEventFilter), meth_QObject_removeEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_removeEventFilter)},
    {SIP_MLNAME_CAST(sipName_sender), meth_QObject_sender, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_sender)},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), meth_QObject_senderSignalIndex, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_senderSignalIndex)},
    {SIP_MLNAME_CAST(sipName_setObjectName), meth_QObject_setObjectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setObjectName)},
    {SIP_MLNAME_CAST(sipName_setParent), meth_QObject_setParent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setParent)},
    {SIP_MLNAME_CAST(sipName_setProperty), meth_QObject_setProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setProperty)},
    {SIP_MLNAME_CAST(sipName_signalsBlocked), meth_QObject_signalsBlocked, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_signalsBlocked)},
    {SIP_MLNAME_CAST(sipName_startTimer), meth_QObject_startTimer, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_startTimer)},
    {SIP_MLNAME_CAST(sipName_thread), meth_QObject_thread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_thread)},
    {SIP_MLNAME_CAST(sipName_timerEvent), meth_QObject_timerEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_timerEvent)},
    {SIP_MLNAME_CAST(sipName_tr), (PyCFunction)meth_QObject_tr, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_tr)},
    {SIP_MLNAME_CAST(sipName_trUtf8), (PyCFunction)meth_QObject_trUtf8, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_trUtf8)}
};


/* Define this type's signals. */
static const pyqt4QtSignal signals_QObject[] = {
    {"destroyed(QObject*)", "\1QObject.destroyed[QObject]", 0, 1},
    {"destroyed()", "\1QObject.destroyed", 0, 1},
    {0, 0, 0, 0}
};


extern "C" {static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *);}
static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *sipPyType)
{
    PyObject *sipPy;
#line 362 "/home/desa2/PyQt-x11-gpl-4.10.4/sip/QtCore/qobject.sip"
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
#line 2115 "/home/desa2/PyQt-x11-gpl-4.10.4/QtCore/sipQtCoreQObject.cpp"

    return sipPy;
}

sipVariableDef variables_QObject[] = {
    {ClassVariable, sipName_staticMetaObject, (PyMethodDef *)varget_QObject_staticMetaObject, NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_QObject, "\1QObject(QObject parent=None)");


pyqt4ClassTypeDef sipTypeDef_QtCore_QObject = {
{
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_NONLAZY|SIP_TYPE_CLASS,
        sipNameNr_QObject,
        {0}
    },
    {
        sipNameNr_QObject,
        {0, 0, 1},
        41, methods_QObject,
        0, 0,
        1, variables_QObject,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QObject,
    sipNameNr_PyQt4_QtCore_pyqtWrapperType,
    -1,
    0,
    0,
    init_type_QObject,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QObject,
    0,
    0,
    0,
    release_QObject,
    cast_QObject,
    0,
    0,
    0,
    0,
    final_QObject,
    0
},
    &QObject::staticMetaObject,
    0,
    signals_QObject,
};
